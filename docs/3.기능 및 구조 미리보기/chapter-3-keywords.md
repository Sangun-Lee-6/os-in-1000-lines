# chapter-3-keywords

## 📌 멀티태스킹 (Multitasking)

✅ 개념

- 하나의 CPU에서 여러 프로세스를 번갈아가며 실행하는 기능
- 사용자 입장에서는 동시에 여러 앱이 실행되는 것처럼 보이게 함
- OS가 context switch를 수행하면서 이를 지원함

## 📌 예외처리 (Exception Handler)

✅ 개념

- 프로세스에서 오류가 발생하거나 이벤트(시스템 콜 등)가 발생했을 때 OS가 개입해서 처리하는 메커니즘
- 예외(Exception), 인터럽트(Interrupt) 포함

✅ 이 프로젝트에서 예시

- 잘못된 명령어 실행 시 커널이 오류 메시지 출력 후 종료

## 📌 페이징 (Paging)

✅ 개념

- OS가 논리 주소를 물리 주소로 변환하기 위해 사용하는 메모리 관리 기법
- 여러 프로세스가 동시에 실행돼도, 서로 메모리를 침범하지 않아야함 → ∴ 각 프로세스에게 논리 주소를 주고 실제 물리 메모리 접근은 OS가 페이지 테이블을 통해 조절

## 📌 시스템 콜 (System Calls)

✅ 개념

- 사용자 프로그램이 OS의 기능을 요청하는 방법
- User mode에서 Kernel mode로 전환이 필요함

✅ 이 프로젝트에서 예시

- `ecall` 명령어로 커널 기능 요청
- 사용자 애플리케이션이 `write`, `exit` 등 시스템 콜을 호출

## 📌 디바이스 드라이버 (Device Drivers)

✅ 개념

- OS가 HW 장치와 직접 소통할 수 있게 해주는 모듈
- 디스크, 키보드 등 HW 장치의 제어에 대한 인터페이스를 제공

## 📌 파일 시스템 (File System)

✅ 개념

- 디스크에 저장된 데이터를 파일 단위로 관리하는 시스템
- 파일 생성, 읽기, 쓰기, 삭제 등의 기능을 제공

## 📌 명령줄 셸 (Command-line Shell)

✅ 개념

- 사용자가 명령어를 입력하여 컴퓨터를 제어할 수 있게 해주는 프로그램
- 운영체제의 인터페이스 계층

## 📌 인터럽트 처리 (Interrupt Handling)

✅ 개념

- CPU가 외부 장치의 요청을 감지하여 작업을 일시 중단하고 처리하는 메커니즘
- ex. 키보드 입력, 디스크 데이터 도착 등

✅ 이 프로젝트에서는

- 인터럽트를 사용하지 않고, 장치 상태를 직접 확인하는 폴링(polling) 방식 사용
- 즉, CPU가 계속 디바이스를 확인하는 busy-waiting 루프로 대체함
- 단순하지만 비효율적 (실제 OS에서는 대부분 인터럽트 방식 사용)

## 📌 타이머 처리 (Timer Processing)

✅ 개념

- 주기적인 시계 신호(타이머 인터럽트) 를 기반으로 OS가 작업 전환 시점을 제어
- 선점형 멀티태스킹의 핵심 요소

✅ 이 프로젝트에서는

- 타이머 인터럽트 없음 → ∴ 선점형 멀티태스킹 불가
- 각 프로세스가 스스로 CPU를 반납해야 함 (협력형 방식 사용)

## 📌 협력형 vs 선점형 멀티태스킹

| 구분     | 협력형(Cooperative)                | 선점형(Preemptive)                      |
| -------- | ---------------------------------- | --------------------------------------- |
| CPU 제어 | 프로세스가 스스로 CPU를 양보       | 타이머 인터럽트 등으로 OS가 강제로 전환 |
| 안정성   | 구현 쉬움, 단 실수로 CPU 점유 가능 | 더 안전하고 유연함                      |
| 예시     | 옛날 Mac OS, 이 프로젝트           | 리눅스, 윈도우 등 대부분 OS             |

## 📌 IPC (Inter-process Communication, 프로세스 간 통신)

✅ 개념

- 서로 다른 프로세스가 데이터를 주고받는 메커니즘
- ex. 파이프, 메시지 큐, 공유 메모리, 소켓 등

## 📌 각 파일에 대한 설명

📁 `disk/` : 파일 시스템용 디렉터리

- OS가 사용할 가상의 디스크 공간

📄 `common.c` : 커널/유저 공용 라이브러리

- 기본 함수(ex. printf, memset, strlen)를 정의한 파일
- 사용자 프로그램과 커널에서 공통적으로 필요한 기능을 한 곳에 구현해둔 것

📄 `common.h` : 공용 헤더

- common.c에서 사용하는 구조체 정의, 상수 선언
- common.c의 기능을 다른 파일이 사용할 수 있도록 인터페이스 제공

📄 `kernel.c` : 운영체제 커널의 핵심

- 프로세스 생성, 관리, 시스템 콜 처리, 디바이스 드라이브, 파일 시스템 등 구현

📄 `kernel.h` : 커널 전용 헤더

- 커널 내부에서 사용하는 구조체, 상수, 함수 선언

📄 `kernel.ld` : 커널 링커 스크립트

- 컴파일된 코드들이 메모리의 어디에 배치될 지 정의하는 스크립트
- ∵ 커널은 특정 메모리 주소에 올라야 제대로 동작하므로 메모리 배치에 대한 정의가 필요

📄 `shell.c` : 명령줄 셸

- 사용자가 명령어를 입력하면 해당 기능을 실행하는 터미널 프로그램

📄 `user.c` : 유저 프로그램용 라이브러리

- 유저 프로그램이 커널 기능을 사용할 수 있도록 도와주는 함수들
- 시스템 콜 이용

📄 `user.h` : 유저용 헤더

- user.c에서 사용되는 함수, 상수, 구조체 정의

📄 `user.ld` : 유저 링커 스크립트

- 유저 프로그램이 메모리의 어디에 로드될지 정의하는 스크립트
- ∵ 커널과 유저 프로그램은 각각 서로 다른 메모리 공간을 사용해야하므로

📄 `run.sh` : 실행 스크립트

- 커널과 유저 프로그램을 컴파일하고 QEMU에서 실행하는 자동화 스크립트
