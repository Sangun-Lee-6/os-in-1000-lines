# chapter-2-keywords

## 📌 ISA(Instruction Set Architecture)

✅ 개념

- ISA : CPU가 이해하고 실행할 수 있는 기계어 명령어들의 정의서

✅ ISA에서 정의하는 것

- 지원하는 명령어들(`add`, `load`, `jump`, `ecall` 등)
- 레지스터 구조
- 메모리 접근 방식

✅ 예시

| ISA 종류    | 특징                                                    |
| ----------- | ------------------------------------------------------- |
| x86 (Intel) | 가장 널리 쓰이는 복잡한 ISA (CISC 기반)                 |
| ARM         | 모바일/임베디드 장치에 많이 사용                        |
| RISC-V      | 교육용 + 오픈소스 ISA, 단순하고 모듈화 구조 (RISC 기반) |

✅ OS 프로젝트에서 ISA

- LLVM이 RISC-V라는 ISA를 기준으로 컴파일

```
[C 소스 코드]
    ↓   (Clang/LLVM Frontend)
[RISC-V용 LLVM IR 생성]
    ↓   (LLVM Backend - 타겟: RISC-V)
[RISC-V용 목적파일(.o)]
    ↓   (LLD 링커)
[ELF 실행파일: kernel.elf]
```

<br>

## 📌 레지스터란 무엇인가

✅ 용어: 레지스터 (Register)

✅ 개념

- CPU 내부에 있는 매우 빠른 임시 저장 공간
- 연산에 직접 사용됨

✅ RISC-V의 범용 레지스터

- `x0` 부터 `x31`까지, 32개의 범용 레지스터가 있음
- `x0`: 항상 값이 0
- `x1`: `ra` (return address)
- `x2`: `sp` (stack pointer)
- `x10 ~ x17`: 함수 인자/반환값용 레지스터(`a0 ~ a7`으로 별칭 존재)

✅ 사용 예시

- `x5 = x1 + x2`를 의미함

```
add x5, x1, x2
```

<br>

## 📌 사칙연산 (`add`, `sub`, `mul`, `div` 등)

✅ 용어: 산술 연산 명령어 (Arithmetic instructions)

✅ 개념

- 레지스터에 저장된 값을 기반으로 사친 연산을 수행
- 연산 결과는 다시 레지스터에 저장됨

✅ 사용 예시

```
add x6, x3, x4   # x6 = x3 + x4
sub x7, x6, x5   # x7 = x6 - x5
mul x8, x1, x2   # x8 = x1 * x2
div x9, x8, x3   # x9 = x8 / x3
```

<br>

## 📌 메모리 접근 (`lw`, `sw` 등)

✅ 용어: 로드/스토어 명령어 (Load / Store)

✅ 개념

- RISC-V는 Load-Store 구조로, 메모리에서 직접 연산 불가
- 데이터를 메모리에서 레지스터로 가져오거나(`lw`), 레지스터 값을 메모리에 저장(`sw`)해야 함

👉 `lw`

- load word
- 메모리에서 4바이트를 읽어서 레지스터에 저장

👉 `sw`

- store word
- 레지스터에 있는 4바이트를 메모리에 저장

✅ 사용 예시

```
# x5가 가리키는 주소에서 0바이트 떨어진 위치의 4바이트 값을 읽어서, 그 값을 x10에 저장
# x10 ← 메모리[x5 + 0]
lw x10, 0(x5)

# x5가 가리키는 주소에서 4바이트 떨어진 위치에 x11 값을 저장
# 메모리[x5 + 4] ← x11
sw x11, 4(x5)
```

<br>

## 📌 분기 명령 (`beq`, `bne`, `blt`, `bgez` 등)

✅ 용어 : 조건 분기 명령어 (Conditional Branch Instructions)

✅ 개념

- 특정 조건이 참일 때만 다른 주소로 점프하도록 하는 명령어
- 흐름 제어(조건문, 루프 등)에 필수

✅ 사용 예시

```
beq x1, x2, label   # if (x1 == x2) → label로 점프
bne x1, x2, label   # if (x1 != x2) → label로 점프
blt x3, x4, label   # if (x3 < x4) → label로 점프
bgez x5, label      # if (x5 >= 0) → label로 점프
```

✅ 명령어 의미

| 축약어 | Full Name                               | 의미                                      |
| ------ | --------------------------------------- | ----------------------------------------- |
| `beq`  | Branch if Equal                         | 두 값이 같으면 분기                       |
| `bne`  | Branch if Not Equal                     | 두 값이 다르면 분기                       |
| `blt`  | Branch if Less Than                     | 왼쪽 값이 오른쪽보다 작으면 분기 (signed) |
| `bgez` | Branch if Greater than or Equal to Zero | 값이 0 이상이면 분기 (signed)             |

<br>

## 📌 함수 호출

✅ 개념

- 현재 위치를 저장하고 함수 시작 주소로 점프
- 함수가 끝나면 저장된 주소로 다시 돌아옴
- `ra(x1)` 레지스터 : 복귀 주소 저장

✅ 명령어

- **`jal`**(Jump and Link)
- **`jalr`**(Jump and Link Register)

✅ 사용 예시

```
jal x1, my_function   # x1 ← return address, jump to my_function
...
my_function:
  ...                 # 함수 로직
  jr x1               # 복귀
```

<br>

## 📌 스택의 구조

✅ 개념

- 함수 호출 시 지역 변수 저장, 복귀 주소 저장 등을 위한 LIFO 구조의 메모리 공간
- `sp`(x2)는 스택의 최상단 위치를 가리킴
- 스택은 보통 아래 방향(주소 감소)으로 확장됨

✅ 사용 예시

```
addi sp, sp, -16    # 스택 공간 확보
sw x1, 12(sp)       # x1(복귀 주소) 저장
...
lw x1, 12(sp)       # 복귀 주소 복원
addi sp, sp, 16     # 스택 복구
```

<br>

## 📌 즉시값 (Immediate)

✅ 개념

- 연산에 직접 숫자 값 그 자체를 사용하는 것
- 메모리나 레지스터에서 참조하는 것이 아니라 명령어에 퐇마된 상수 값

✅ 예시

- 아래에서 `123`은 즉시값

```nasm
addi a0, a1, 123
```

<br>

## 📌 오퍼랜드 (Operand)

✅ 개념

- 어셈블리 명령어에서 연산에 사용되는 대상들

✅ 예시

- 레지스터 주소, 메모리 주소, 즉시값

<br>

## 📌 ABI Name이란?

✅ 용어 : ABI Name

- Application Binary Interface Name
- 레지스터의 별칭(alias)

✅ 개념

- 레지스터의 숫자(x0, x1 등)만 보고 레지스터의 용도를 알기 어려움
- ∴ 레지스터의 용도에 따라 이름을 붙여 가독성을 높이고 함수 호출 규약(ABI)을 따르도록 함
- 어셈블리 코드에서 ABI Name을 사용하는 것이 일반적

✅ 예시 비교

- 일반 숫자 레지스터 사용 시

```
addi x10, x11, 1    # x11에 1을 더해서 x10에 저장
```

- ABI 이름 사용 시

```
addi a0, a1, 1      # 함수 인자 a1 + 1 → 반환값 a0로 설정
```

- 같은 코드지만, ABI 이름을 사용했을 때 함수의 인자라는 의미가 더 명확함

<br>

## 📌 CPU의 특권 수준 (Privilege Levels in RISC-V)

✅ 개념

- 특권 수준 : CPU가 할 수 있는 일을 단계별로 제한하는 `권한 등급`

✅ 특권 수준이 필요한 이유

- 권한을 나눠서 OS와 사용자 앱을 부니라고, 보안, 안정성 확보
- ex. 사용자 앱이 커널/HW에 직접 접근할 수 없도록
- ex. 프로그램이 다른 영역의 메모리를 침범하지 못하도록

✅ 특권 수준 전환 예시

```
부팅
 ↓ (M-mode)
OpenSBI 실행
 ↓ (mret)
운영체제 진입 (S-mode)
 ↓ (sret)
사용자 애플리케이션 실행 (U-mode)
 ↓ (ecall → trap)
커널에게 요청 (S-mode)
 ↓ (sret)
다시 사용자 애플리케이션 실행 (U-mode)
```

<br>

## 📌 CSR

✅ CSR이란

- Control and Status Register
- CPU 내부 상태나 동작을 제어, 확인하는 레지스터

✅ CSR 예시

| 레지스터 이름 | 저장되는 값                    |
| ------------- | ------------------------------ |
| `mstatus`     | 현재 모드, 인터럽트 비트       |
| `sepc`        | trap 발생 시 저장되는 PC 주소  |
| `satp`        | 페이지 테이블의 루트 주소 저장 |

<br>

## 📌 RISC-V의 특권 명령 예시

| 명령어         | 설명                               |
| -------------- | ---------------------------------- |
| `csrr rd, csr` | CSR 값을 읽기                      |
| `csrw csr, rs` | CSR에 값 쓰기                      |
| `csrrw`        | CSR 읽고 쓰기                      |
| `sret`         | S-mode → U-mode로 전환             |
| `sfence.vma`   | TLB 플러시 (페이지 테이블 바꿀 때) |

1️⃣ `csrr rd, csr`

- CSR에서 값을 읽어오기
- CPU 상태를 확인하거나, 컨텍스트 스위치(trap 처리 등) 시 필요한 정보 확보 목적
- 예시 : 현재 특권 수준을 저장한 `mstatus`, 트랩 복귀 주소 `sepc` 등을 읽고 싶을 때

```
csrr t0, sepc    # 트랩 이전 명령어 주소를 t0에 저장
```

2️⃣ `csrw csr, rs`

- CSR에 값을 쓰기
- 트랩 처리 후 복귀할 주소를 설정할 때 (`sepc`) 사용
- 특권 모드 변경, 인터럽트 설정 등 제어가 필요할 때 사용
- 커널이 CPU 동작을 제어할 수 있어야 하므로, CSR 값을 설정할 수 있어야 함

```
csrw sepc, t0    # 복귀 주소 설정
csrw satp, t1    # 페이지 테이블 루트 설정
```

3️⃣ `csrrw rd, csr, rs`

- CSR 값을 읽고, 다른 값으로 교체(swap)
- CSR의 값을 저장해두고, 동시에 새 값을 설정하고 싶을 때
- 원자적으로 읽고 쓰기가 필요한 상황에서 유용 (context switch 같은 동시성 환경)

```
csrrw t0, mstatus, t1    # mstatus를 t0에 백업하고, t1의 값으로 덮어쓰기
```

4️⃣ `sret`

- S-mode → U-mode로 전환 (Trap 복귀)
- U-mode에서 시스템 콜을 호출하면 → S-mode로 trap → trap 처리 후 다시 U-mode로 돌아올 때 사용
- OS가 제어권을 되돌려주는 필수 명령어

```
sret   # 커널 작업 종료 → 유저 모드 복귀
```

5️⃣ `sfence.vma`

- TLB 플러시 (주소 변환 캐시 초기화)
- 페이지 테이블을 변경한 직후, 새로운 주소 변환을 강제하고 싶을 때 사용
- 페이지 테이블이 바뀌었는데 TLB를 안 비우면, 오래된 잘못된 주소로 접근하게 됨

```
sfence.vma x0, x0    # 전체 주소 공간에 대해 TLB 초기화
```

<br>

## 📌 인라인 어셈블리

✅ 용어

- 인라인 어셈블리 (Inline Assembly)
- C 코드 중간에 어셈블리 명령어를 직접 삽입하는 기법

✅ 개념

- C 코드와 어셈블리 코드를 혼합해서 작성할 수 있는 기법
- 별도의 .S 파일 없이 C 코드 내부에 어셈블리 삽입
- GCC 확장 문법(`asm, __asm__)`을 사용
- 레지스터 할당, 스택 정리 등은 컴파일러가 자동 처리
- 일반 C 함수로는 직접 접근할 수 없는 CSR 설정, sret, mret 같은 특권 명령어 실행 등에 필수적

✅ 예시

```c
int x = 5, y;
asm volatile("mv %0, %1" : "=r"(y) : "r"(x));
// y = x 와 동일한 의미
```

- `"mv %0, %1"`: RISC-V 명령어 `mv`로 두 레지스터 값을 복사
- `: "=r"(y)` → 출력 피연산자: 결과를 y에 저장
- `: "r"(x)` → 입력 피연산자: x 값을 레지스터에 할당
- 컴파일러가 `%0`, `%1`에 맞는 실제 레지스터를 자동 배정

✅ 장점

- C 변수와 어셈블리를 자연스럽게 연결 가능
- 컴파일러가 레지스터 사용, 스택 정리, 최적화를 관리해주므로, 실수를 줄일 수 있음
- 성능 최적화가 필요한 부분에 어셈블리를 삽입 가능

✅ 사용되는 상황

- 운영체제 커널 개발 (ex. 문맥 전환, 시스템 콜 진입)
- 하드웨어 제어 (ex. 인터럽트 처리기, MMU 설정)
- 성능이 중요한 루틴 최적화
